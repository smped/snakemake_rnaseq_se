---
title: "Post-Alignment QC"
author: "Stephen Pederson"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---


```{r setup, echo=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.height = 7,
  fig.width = 10
)
```

```{r packages}
library(ngsReports)
library(tidyverse)
library(yaml)
library(scales)
library(pander)
library(glue)
library(plotly)
library(edgeR)
library(ggfortify)
```

```{r options}
panderOptions("table.split.table", Inf)
panderOptions("big.mark", ",")
theme_set(theme_bw())
```

```{r config}
config <- here::here("config/config.yml") %>%
  read_yaml()
suffix <- paste0(config$tag)
sp <- config$ref$species %>%
  str_replace("(^[a-z])[a-z]*_([a-z]+)", "\\1\\2") %>%
  str_to_title()
```

```{r samples}
samples <- config$samples %>%
  here::here() %>%
  read_tsv() %>%
  mutate(
    Filename = paste0(sample, suffix)
  )
```

```{r check_config}
config$analysis <- config$analysis %>%
  lapply(intersect, y = colnames(samples)) %>%
  .[vapply(., length, integer(1)) > 0]
```

```{r add_columns}
if (length(config$analysis)) {
  samples <- samples %>%
    unite(
      col = group, 
      any_of(as.character(unlist(config$analysis))), 
      sep = "_", remove = FALSE
    )
} else {
  samples$group <- samples$Filename
}
```


```{r group_cols}
group_cols <- hcl.colors(
  n = length(unique(samples$group)), 
  palette = "Zissou 1"
  ) %>%
  setNames(unique(samples$group))
```


```{r setFigureSizes}
fh <- round(6 + nrow(samples) / 15, 0)
```

# Alignment Statistics

```{r alnStats}
alnStats <- here::here() %>%
  list.files(recursive = TRUE, pattern = "Log.final.out") %>%
  importNgsLogs(type = "star", stripPaths = FALSE) %>%
  mutate(
    Filename = basename(dirname(Filename))
  ) %>%
  left_join(samples, by = "Filename") 
```

- Across all files the total alignment rate ranged between `r pander(percent(range(alnStats$Total_Mapped_Percent)/100))`
- Uniquely aligned reads ranged between `r pander(percent(range(alnStats$Uniquely_Mapped_Reads_Percent/100)))`
- The percentages of mapped reads which aligned to 'too many' locations and were discarded was between `r pander(percent(range(alnStats$Percent_Of_Reads_Mapped_To_Too_Many_Loci)/100))`

```{r plotAlnStats, fig.height=8, fig.cap = "Alignment rates across all libraries"}
ggplotly(
  alnStats %>%
    dplyr::select(
      Filename, group, contains("Percent"), -Total_Mapped_Percent
    ) %>%
    mutate(
      Unmapped = Percent_Of_Reads_Unmapped_Too_Many_Mismatches +
        Percent_Of_Reads_Unmapped_Too_Short +
        Percent_Of_Reads_Unmapped_Other
    ) %>%
    dplyr::select(
      Filename, group, contains("Mapped", ignore.case = FALSE), Unmapped
    ) %>%
    pivot_longer(
      cols = contains("mapped"),
      names_to = "Category",
      values_to = "Percent"
    ) %>%
    mutate(
      Category = str_remove_all(Category, "(_Percent|Percent_Of_Reads_)"),
      Category = str_replace_all(Category, "_", " "),
      Category = as.factor(Category),
      Category = relevel(Category, ref = "Uniquely Mapped Reads"),
      Category = fct_rev(Category)
    ) %>%
    ggplot(aes(Filename, Percent, fill = Category)) +
    geom_col(colour = "black", size = 0.1) +
    facet_wrap(~group, scales = "free_x") +
    scale_y_continuous(expand = expansion(c(0, 0.05))) +
    scale_fill_viridis_d(option = "E", direction = -1) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank()
    )
)
```




# Read Assignment To Genes

```{r countSummary}
countSummary <- here::here("data/aligned/counts/counts.out.summary") %>%
  importNgsLogs(type = "featureCounts") %>%
  mutate(
    Total = rowSums(
      dplyr::select_if(., is.numeric)
    ),
    Filename = basename(dirname(Sample))
  ) %>%
  dplyr::select(-Sample) %>%
  left_join(samples)
```

Read assignment to genes was performed using Ensembl release `r config$ref$release` which used the genome build `r config$ref$build` for generation of gene models.
When assigning reads to genes, `featureCounts` was run setting the following criteria:

- Libraries were assumed to be *`r with(config$featureCounts, case_when(strandedness == 0 ~ "unstranded", strandedness == 1 ~ "positively stranded", strandedness == 2 ~ "negatively stranded"))`*
- The *minimum percentage* of a read which needed to overlap an exon before being counted was `r percent(config$featureCounts$fracOverlap)`
- In addition to the minimum percentage, *a minimum of `r config$featureCounts$minOverlap` bases* must also overlap an exon before a read is counted
- The *minimum alignment quality score* for a read to be counted was `r config$featureCounts$minQual`
`r if (grepl("-M", config$featureCounts$extra))paste("- Counting of multi-mapped reads was permitted", ifelse(grepl("--fraction", config$featureCounts$extra), "using fractional counts", ""))` 

Using these settings:

- The percentages of reads assigned to genes ranged between `r pander(percent(range(with(countSummary, Assigned / Total))))`
- Of the total reads:
    - Between  `r pander(percent(range(with(countSummary, Unassigned_MultiMapping / Total))))` were unassigned due to multi-mapping
    - Between  `r pander(percent(range(with(countSummary, Unassigned_NoFeatures / Total))))` were aligned but didn't overlap any known genes
    - Between  `r pander(percent(range(with(countSummary, Unassigned_Overlapping_Length / Total))))` were unassigned as they failed the proportion overlapping criteria
    - Between  `r pander(percent(range(with(countSummary, Unassigned_Ambiguity / Total))))` were unassigned as they were considered ambiguous
    
```{r plotAssignmentRate, fig.height=8, fig.cap = "Rate of mapped reads being assigned to genes"}
ggplotly(
  countSummary %>%
    pivot_longer(
      cols = contains("assigned"),
      names_to = "Status",
      values_to = "Reads"
    ) %>%
    dplyr::filter(Reads > 0) %>%
    mutate(
      Percent = round(100 * Reads / Total, 2)
    ) %>%
    arrange(Percent) %>%
    mutate(
      Status = str_replace_all(Status, "Unassigned_", "Unassigned: "),
      Status = str_replace_all(Status, "_", " "),
      Status = fct_inorder(Status)) %>%
    ggplot(aes(sample, Percent, fill = Status)) +
    geom_col() +
    facet_wrap(~group, scales = "free") +
    scale_fill_viridis_d(option = "E", direction = -1) +
    scale_y_continuous(
      labels = ngsReports:::.addPercent,
      expand = expansion(c(0, 0.05))
    ) + 
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank()
    )
)
```

    
# Gene Expression

## Total Detected Genes

```{r counts}
counts <- here::here("data/aligned/counts/counts.out") %>%
  read_tsv(comment = "#") %>%
  rename_all(str_remove_all, pattern = "/Aligned.+") %>%
  rename_all(basename) %>%
  dplyr::select(-Chr, -Start, -End, -Strand, -Length) %>%
  column_to_rownames("Geneid") %>%
  as.matrix()
```

- Of the `r comma(nrow(counts))` genes defined in this annotation build, `r comma(sum(rowSums(counts) == 0))` genes had no reads assigned in any samples.
- The numbers of genes with at least one read assigned ranged between `r pander(comma(range(colSums(apply(counts, MARGIN = 2, as.logical)))))` across all samples.

```{r plotDetectedGenes, fig.height=6, fig.width=8, fig.cap = "Total numbers of genes detected across all samples and groups."}
counts %>%
  as_tibble() %>%
  mutate(
    across(everything(), as.logical)
  ) %>%
  summarise(
    across(everything(), sum)
  ) %>%
  pivot_longer(
    everything(), names_to = "Filename", values_to = "Detected"
  ) %>%
  left_join(samples) %>%
  ggplot(aes(group, Detected, colour = group)) +
  geom_point() +
  geom_segment(
    aes(xend = group, y = 0, yend = Detected),
    data = . %>% 
      group_by(group) %>%
      summarise(Detected = min(Detected)),
    colour = "black", size = 1/4) +
  scale_y_continuous(labels = comma, expand = expansion(c(0, 0.05))) +
  scale_colour_manual(values = group_cols) +
  labs(
    x = "Group", 
    y = "Genes Detected",
    colour = "Group"
  )
```

## Library Sizes

After assignment to genes, library sizes ranged between `r pander(comma(range(colSums(counts))))` reads, with a median library size of `r pander(comma(median(colSums(counts))))` reads.

```{r plotLibSize, fig.height = 6, fig.width=8, fig.cap = "Library sizes across all samples and groups"}
counts %>%
  colSums() %>%
  enframe(
    name = "Filename", value = "Library Size"
  ) %>%
  left_join(samples) %>%
  ggplot(aes(group, `Library Size`, colour = group)) +
  geom_point() +
  geom_segment(
    aes(xend = group, y = 0, yend = `Library Size`),
    data = . %>% 
      group_by(group) %>%
      summarise(`Library Size` = min(`Library Size`)),
    colour = "black", size = 1/4) +
  scale_y_continuous(labels = comma, expand = expansion(c(0, 0.05))) +
  scale_colour_manual(values = group_cols) +
  labs(
    x = "Group", 
    colour = "Group"
  )
```


## PCA

```{r prcomp}
pca <- counts %>%
  .[rowSums(. == 0) < ncol(.)/2,] %>%
  cpm(log = TRUE) %>%
  t() %>%
  prcomp()
```

A PCA was performed using logCPM values from the subset of `r comma(sum(rowSums(counts == 0) < ncol(counts)/2))` genes with at least one read in more than half of the samples.

```{r plotPCA, fig.height=6, fig.width=8, fig.cap="PCA plot of all samples"}
pca %>%
  autoplot(data = samples, colour = "group") +
  labs(colour = "Group") +
  scale_colour_manual(values = group_cols)
```

